from __future__ import annotations
import logging
from typing import Dict, List

# ──────────────────────────────────────────────
#  Logger
# ──────────────────────────────────────────────
logger = logging.getLogger("villain_exploit")
logger.setLevel(logging.INFO)
if not logger.handlers:
    _h = logging.StreamHandler()
    _h.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
    logger.addHandler(_h)

# ──────────────────────────────────────────────
#  Tag dictionaries
# ──────────────────────────────────────────────
STATION_TAGS:   List[str] = ["station", "calling station", "showdown monkey"]
NIT_TAGS:       List[str] = ["nit", "overfolder", "weak-tight"]
MANIAC_TAGS:    List[str] = ["maniac", "aggro", "high af"]
SHOWDOWN_TAGS:  List[str] = ["shows down light", "showdown monkey"]

# Helper for case-insensitive membership
def _tag_match(tag_list: List[str], label: str) -> bool:
    if not label:
        return False
    label = label.lower()
    tag_list = [t.lower() for t in tag_list]
    return any(label == t or label in t for t in tag_list)

# ──────────────────────────────────────────────
def apply_villain_exploit(game_state: Dict, standard_recommendation: str) -> str:
    """
    Post-process solver/GTO recommendation according to villain persona.
    """

    if not standard_recommendation:
        return "RECOMMEND: UNKNOWN"

    standard_recommendation = standard_recommendation.strip()
    rec_std = standard_recommendation.upper()
    act_std = (game_state.get("action") or "").upper()

    vp = game_state.get("villain_profile", {}) or {}
    hp = game_state.get("hero_profile", {}) or {}

    player_img = vp.get("player_image", "").lower()
    hero_img   = hp.get("player_image", "").lower()
    street     = (game_state.get("street") or "").lower()
    history    = " ".join(vp.get("recent_history", [])).lower()

    # Infer nit/maniac if tag missing
    if not player_img:
        vpip = vp.get("vpip", 0.22)
        af   = vp.get("af", 1.5)
        if vpip < 0.18 and af < 1.2:
            player_img = "nit"
        elif vpip > 0.35 and af > 2.5:
            player_img = "maniac"

    # 1. Station exploit
    if _tag_match(STATION_TAGS, player_img) and "river" in street:
        if "BLUFF" in rec_std:
            logger.info("Exploit (%s): skip river bluff.", player_img)
            return "RECOMMEND: CHECK"
        if any(tag in rec_std for tag in ("VALUE-BET", "BET")):
            logger.info("Exploit (%s): favour larger value bet.", player_img)
            return standard_recommendation

    # 2. Nit exploit
    if _tag_match(NIT_TAGS, player_img):
        if any(k in act_std for k in ("3-BET", "AGGRESSION", "C-BET", "RAISE")):
            logger.info("Exploit (%s): increase bluff frequency.", player_img)
            return "RECOMMEND: BLUFF"

    # 3. Maniac exploit
    if _tag_match(MANIAC_TAGS, player_img):
        if "FOLD" in rec_std:
            logger.info("Exploit (%s): call wider.", player_img)
            return "RECOMMEND: CALL"
        if "BLUFF" in rec_std:
            logger.info("Exploit (%s): avoid bluff.", player_img)
            return "RECOMMEND: CHECK"

    # 4. 'Never folds river' note
    if "never folds river" in history or _tag_match(STATION_TAGS, player_img):
        if "river" in street and "BLUFF" in rec_std:
            logger.info("Exploit: note says never folds river.")
            return "RECOMMEND: CHECK"

    # 5. Shows-down-light exploit
    if (_tag_match(SHOWDOWN_TAGS, player_img)
            or any(tag in history for tag in SHOWDOWN_TAGS)):
        if "BLUFF" in rec_std:
            logger.info("Exploit (%s): no bluff vs showdown-light.", player_img)
            return "RECOMMEND: CHECK"
        if "FOLD" in rec_std and "river" in street:
            logger.info("Exploit (%s): call lighter on river.", player_img)
            return "RECOMMEND: CALL"

    # 6. Hero image maniac
    if hero_img == "maniac" and "BLUFF" in rec_std:
        logger.info("Exploit: hero perceived maniac → reduce bluff.")
        return "RECOMMEND: CHECK"

    logger.debug("No exploit triggered; keep solver output.")
    return standard_recommendation
